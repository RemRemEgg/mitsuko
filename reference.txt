# Meta tags:
comments (bool: false)
    -> Should comments + whitespace be saved
description (String: A Datapack)
    -> Description used in pack.mcmeta (supports ยง)
name (String: Untitled)
    -> Datapack's name
x namespace (String: ex)
    -> Datapack's namespace
remgine (bool: true)
    -> Is remgine enabled
version (int)
    -> Datapack's Version

# General Tags:
debug (0-2: 0)
    -> Debug verbosity
optimizations (0..?: 0)
    -> How far to optimize code
recursive_replace (0..255: 3)
    -> How any recursions to go for internal values


# Code:
//<comment>
    -> Parses to '#<comment>' if #[comments = true]
<function>()
    -> function <function>
#<functions>()
<command> [args...]
    -> <command> [args...]
cmd <command> [args...]
    -> <command> [args...]
if !(condition) : **
if [!]<condition> : **
    -> execute <if | unless> <statement> run **
^create <name> <type> [displayName]
    -> scoreboard objectives add <name> <type> [displayName]
^<selector>:<board>
^temp -> ^$temp:remgine.temp
^temp2 -> ^$temp2:remgine.temp
^var = < num | math | ^var | @nbt >
    -> scoreboard players <operation | set> <var> [=] <other>
score ^<var> < + | - | / | * | < | > | <> | % > < num | $var >
    -> [set temp] + scoreboard players operation <var> <operation> <other | temp>
exe < as | at | ast > @<selector> < ... | run > **
    -> execute <as | at> <selector> [at @s] ... run **
ifs [!]<condition> {
    **
}
    -> function + execute <if | unless> <statement> run function
set <name> <value>
    -> Does not compile, stores internal value
*{<name>}
    -> Place anywhere to retrieve the value stored from let
*JSON{}
repeat < count | $var > {
    **
}
    -> Repeats the given code <count> or <$var> times

# Conditions:
$<var> < = | < | > | <= | >= | matches > < $var | range >
    -> score <var> <operation> <other | range>
predicate <predicate>
    ->predicate <predicate>

## Requires remgine

# Code:
rmm @<selector> < num | $var >
    -> scoreboard players <set | operation> <selector> rem.rmm <add | = > <other | num> + function rem:actions/rmm
csel player from id < num | $var >
    -> scoreboard players <set | operation> $temp < = | set> <other | num> + rem.id  function rem:actions/csel_player_id

# Statements:
random <num>
    -> if predicate rem:rnd/<num>

*NEAR1
*JSON
*{NS}
*{NAME}
*{INT_MAX}
*{INT_MIN}

remgine.ignore = should be completely ignored by other datapack's commands
remgine.no_target = should be completely ignored by other datapack's damaging/healing, weapons, items, effects, homing, etc

optimizations
0 : none
1 : basic (find/replace, inline blocks)
2 : advanced (global static vars, inline functions)
3 : experimental


todo:
binary search tree


["return","advancement","attribute","bossbar","clear","clone","data","datapack","debug","defaultgamemode","difficulty",
"effect","enchant","execute","experience","fill","forceload","function","gamemode","gamerule","give","help","kick","kill",
"list","locate","loot","me","msg","particle","playsound","publish","recipe","reload","item","say","schedule","scoreboard",
"seed","setblock","setworldspawn","spawnpoint","spectate","spreadplayers","stopsound","summon","tag","team","teammsg","teleport",
"tell","tellraw","time","title","tm","tp","trigger","weather","worldborder","xp","jfr","place","fillbiome","ride","damage"]